# 구현이 아닌 인터페이스를 테스트합니다.

테스트 코드는 구현 코드를 의존합니다. 테스트 코드가 구현 코드의 속 사정을 많이 알면 알수록 둘 사이의 의존성은 강해집니다. 강한 의존성은 변경에 취약한 구조를 만듭니다. 작은 변경에도 쉽게 테스트 코드가 깨질 때 "테스트가 취약(fragile)"하다고 합니다. 변경에 강한 테스트를 작성하려면 구현 코드의 상세 구현이 아닌 인터페이스를 테스트해야 합니다.

### 변경에 취약한 테스트 코드

아래의 코드는 단언이 세부 구현을 너무 많이 알고 있습니다. `_items` 프로퍼티의 타입을 변경하거나, 이름을 변경한다면 테스트도 영향을 받을 겁니다.

```typescript
it("새로운 아이템을 목록에 추가해야 한다.", () => {
  // when
  list._items.push("A");
  list._items.push("B");
 
  // then
  expect(list._items[0]).toBe("A");
  expect(list._items[1]).toBe("B");
});
```

변경에 취약한 테스트가 많아지면 리팩터링이 부담스러워 집니다. 리팩터링을 할 때마다 테스트는 깨질 것이고, 깨지는 테스트가 많아지면 리팩터링을 하기가 두려워지기 때문입니다. 그러다가 애꿎은 테스트를 욕합니다. "테스트가 우리를 더 느리게 만든다!"고 말이죠.

### 인터페이스를 테스트하기

list 개체의 공용 인터페이스를 테스트에 이용함으로써 테스트를 변경에 덜 취약하게 만들 수 있습니다.

```typescript
it("새로운 아이템을 목록에 추가해야 한다.", () => {
  list.addItem("A");
  list.addItem("B");
 
  expect(list.toArray()).toBe(["A", "B"]);
});
```

테스트도 코드이기에 일반 설계 원칙은 테스트 코드를 작성할 때도 유효합니다.